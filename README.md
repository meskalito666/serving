# сервис:
Сейчас сервис поднят на машине 167.235.136.60 
Ручки доступны тут http://167.235.136.60:5020/send_query и тут http://167.235.130.89:5020/send_query  
Сервис принимает на вход post-запрос с json формата: {"query": "some_sentence"}, возвращает {"nearest_sentence": "some_sentence"}

# структура файлов:
- actions - шеллы для запуска, остановки и обновления сервисов
- api_gateway, emb_to_txt, serving - папки с сервисами
- idxs - наборы индексов 
- docker-compose.yml - файл для сборки сервисов и start.sh - шелл, который его запускает
- load_model.sh - шелл для загрузки модели

# как это завести (from scratch) и обновить:
1. пара мест, где надо поправить адрес хоста, если заводить на своей машине: /actions/build_n_deploy.sh, docker-compose.yml
2. sudo bash load_model.sh - модель на гитхаб не влезла, поэтому скачиваем с сервера 
3. cd actions
4. ./build_n_push.sh - собираем образы и пушим в registry
5. cd ..
6. ./start.sh - стартуем сервис с помощью docker-compose 

* если нужно обновить индексы:  
   1 cd actions    
   2 sudo bash update.sh - делаем rolling-update и обновляем индексы (дилей 15сек), предусмотрен rollback в случае ошибки   

# как это работает:
1. serving - модель, принимает post запрос с json вида {"instances": ["some_sentence"]} доступна вот тут http://167.235.136.60:8501/v1/models/use_l:predict, возвращает эмбеддинг 
2. api_gateway - сервис получает запрос, отправляет его в модель для трансформации, для полученного эмбеддинга ищет ближайший кластер, отправляет эмбеддинг в сервис с найденым номером кластера, получает ответ в виде наиболее похожего запроса и возвращает его пользователю в json формата: {"nearest_sentence":"some_sentence"} 
3. emb_to_txt_n - сервисы по номерам кластеров, что получают эмбеддинг и возвращают по нему ближайший текстовый запрос 
